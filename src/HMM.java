import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;

public class HMM {
    private double[][] alpha;
    private double[][] beta;
    private double[][] gamma;
    private double[][][] diGamma;
    private double[] scaleFactors;

    private ObservationSequence observationSequence;

    private int N;
    private int M;
    private int T;

    private Lambda lambda;

    public HMM(int N, int M) {
        this.lambda = new Lambda(N, M);
        this.N = N;
        this.M = M;
    }

    private void initAll() {
        this.T = observationSequence.getT();
        this.scaleFactors = new double[T];
        alpha = new double[T][N];
        beta = new double[T][N];
        gamma = new double[T][N];
        diGamma = new double[T][N][N];
    }

    public void trainHMM(int maxIterations, String trainingSetDir) {
        File trainingSet = new File(trainingSetDir);
        loadObservationSequence(trainingSet);
        this.initAll();

        int currentIteration = 0;
        double oldLogProb = Double.NEGATIVE_INFINITY;
        double logProb = -Double.MAX_VALUE;

        while ((currentIteration < maxIterations) && (logProb > oldLogProb)) {
            oldLogProb = logProb;
            alphaPass();
            betaPass();
            computeGammaDiGamma();
            reEstimateLambda();

            currentIteration++;
            logProb = this.computeScore();
        }
        System.out.println("Training completed!\n\tIterations: " + currentIteration +
                "\n\tTraining Score: " + logProb);
    }

    private void loadObservationSequence(File trainingSetDir) {
        this.observationSequence = new ObservationSequence(trainingSetDir);
    }

    private void alphaPass() {
        scaleFactors[0] = 0;

        //computing alpha_0[i]
        for (int i = 0; i < N; i++) {
            alpha[0][i] = lambda.getPi()[i] * lambda.getB()[i][observationSequence.getObsSeq().get(0)];
            scaleFactors[0] += alpha[0][i];
        }

        //scale alpha_0[i]
        scaleFactors[0] = 1 / scaleFactors[0];
        for (int i = 0; i < N; i++) {
            alpha[0][i] *= scaleFactors[0];
        }

        //compute alpha_t[i]
        for (int t = 1; t < T; t++) {
            scaleFactors[t] = 0;
            for (int i = 0; i < N; i++) {
                alpha[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    alpha[t][i] += alpha[t - 1][j] * lambda.getA()[j][i];
                }
                alpha[t][i] *= lambda.getB()[i][observationSequence.getObsSeq().get(t)];
                scaleFactors[t] += alpha[t][i];
            }
            //scale alpha_t[i]
            scaleFactors[t] = 1 / scaleFactors[t];
            for (int i = 0; i < N; i++) {
                alpha[t][i] *= scaleFactors[t];
            }
        }
    }

    private void betaPass() {
        for (int i = 0; i < N; i++) {
            beta[T - 1][i] = scaleFactors[T - 1];
        }

        for (int t = T - 2; t >= 0; t--) {
            for (int i = 0; i < N; i++) {
                beta[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    beta[t][i] += lambda.getA()[i][j] * lambda.getB()[j][observationSequence.getObsSeq().get(t + 1)]
                            * beta[t + 1][j];
                }
                //scale beta_t[i]
                beta[t][i] *= scaleFactors[t];
            }
        }
    }

    private void computeGammaDiGamma() {
        for (int t = 0; t < T - 1; t++) {
            for (int i = 0; i < N; i++) {
                gamma[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    diGamma[t][i][j] = alpha[t][i] * lambda.getA()[i][j]
                            * lambda.getB()[j][observationSequence.getObsSeq().get(t + 1)]
                            * beta[t + 1][j];
                    gamma[t][i] += diGamma[t][i][j];
                }
            }
        }
        for (int i = 0; i < N; i++) {
            gamma[T - 1][i] = alpha[T - 1][i];
        }
    }

    private void reEstimateLambda() {
        //re-estimate pi
        for (int i = 0; i < N; i++) {
            lambda.setPi(gamma[0][i], i);
        }

        //re-estimate A
        for (int i = 0; i < N; i++) {
            double denom = 0;
            for (int t = 0; t < T - 1; t++) {
                denom += gamma[t][i];
            }
            for (int j = 0; j < N; j++) {
                double numer = 0;
                for (int t = 0; t < T - 1; t++) {
                    numer += diGamma[t][i][j];
                }
                double value = numer / denom;
                lambda.setA(value, i, j);
            }
        }

        //re-estimate B
        for (int i = 0; i < N; i++) {
            double denom = 0;
            for (int t = 0; t < T; t++) {
                denom += gamma[t][i];
            }
            for (int j = 0; j < M; j++) {
                double numer = 0;
                for (int t = 0; t < T; t++) {
                    if (observationSequence.getObsSeq().get(t) == j)
                        numer += gamma[t][i];
                }
                double value = numer / denom;
                lambda.setB(value, i, j);
            }
        }
    }

    public double testFile(File testFile) {
        double score;
        this.observationSequence = new ObservationSequence(testFile);
        this.initAll();
        alphaPass();
        score = computeScore();

        return score;
    }

    public double computeScore() {
        double logProb = 0;
        for (int i = 0; i < T; i++) {
            logProb += Math.log(scaleFactors[i]);
        }
        logProb = -logProb;

        return logProb;
    }

    public void saveModel(String fileName) {
        File file = new File(fileName);
        try {
            file.createNewFile();
            FileWriter writer = new FileWriter(file);
            writer.write(Integer.toString(N) + "\n");
            writer.write(Integer.toString(M) + "\n");

            for (int i = 0; i < N; i++) {
                writer.write(Double.toString(lambda.getPi()[i]) + "\n");
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    writer.write(Double.toString(lambda.getA()[i][j]) + "\n");
                }
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    writer.write(Double.toString(lambda.getB()[i][j]) + "\n");
                }
            }

            writer.flush();
            writer.close();
        } catch(IOException e) {
            System.err.println("Error in writing model");
            System.exit(1);
        }
    }

    public void loadModel(String fileName) {
        File file = new File(fileName);
        try {
            Scanner sc = new Scanner(file);
            this.N = sc.nextInt();
            this.M = sc.nextInt();

            for(int i=0; i<N; i++) {
                double readValue = sc.nextDouble();
                lambda.setPi(readValue,i);
            }
            for(int i=0; i<N; i++) {
                for(int j=0; j<N; j++) {
                    double readValue = sc.nextDouble();
                    lambda.setA(readValue,i,j);
                }
            }

            for(int i=0; i<N; i++) {
                for(int j=0; j<M; j++) {
                    double readValue = sc.nextDouble();
                    lambda.setB(readValue,i,j);
                }
            }
            sc.close();
        } catch(IOException e) {
            System.err.println("Error in loading the model");
            System.exit(1);
        }
    }
}
