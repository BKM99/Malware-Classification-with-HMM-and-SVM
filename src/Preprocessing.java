import java.io.*;
import java.util.*;
import java.util.stream.IntStream;

/**
 * This class is meant to preprocess one malware family at a time
 * Provides opcode frequency,
 * converting top opcodes to symbols for hidden markov model,
 * and counts the number of files in family.
 */

public class Preprocessing {
    private File family;
    private File[] dirListing;
    private LinkedHashMap<String, Integer> opcodeCount;
    private int fileCount;

    private final char[] char2convert = "abcdefghijklmnopqrstuvwxyz0123456789!@#$".toCharArray(); // 40 chars
    private final int[] int2convert = IntStream.range(1, 40).toArray();
    private final char everythingElse = '*'; //everything outside of top n opcodes will be this symbol
    private final int everythingElseInt = -1; //everything outside of top n opcodes will be this symbol

    private ArrayList<Integer> brownCorpus; //holds the conversion of chars to ints for testing

    public Preprocessing(String dirPath) {
        opcodeCount = new LinkedHashMap<>();
        family = new File(dirPath);
        dirListing = family.listFiles();
        this.fileCount = countFiles();
        countOpcodes();
    }

    /**
     * Intended for testing only
     */
    public Preprocessing() {
        this.brownCorpus = translateBrownToInt();
    }

    public ArrayList<Integer> getBrownCorpus() {
        return brownCorpus;
    }

    //gets the symbol map, then writes new symbols to new file
    public void translate(int n) {
        LinkedHashMap<String, Character> tran = getSymbolMapping(n);
        String dirName = "MaliciaTranslated-top" + n;
        makeDir(dirName); //makes new directory for translated dataset, if already created this does nothing
        String subDirName = dirName + "/" + family.getName();
        makeDir(subDirName); //making sub dir for family, if already created this does nothing

        int count = 1; //counter to append to file name so its unique

        //iterate through each line in sample, if map has the line, then replace with value
        for(File file : dirListing) {
            String newFileName = subDirName + "/" + family.getName() + count + ".txt"; //new file name
            File newFile = new File(newFileName); //creates the new file
            count++;

            try {
                BufferedReader br = new BufferedReader(new FileReader(family + "/" + file.getName())); //reads the malware sample
                BufferedWriter bw = new BufferedWriter(new FileWriter(newFileName,true)); //writes to the newly created file (newFile)
                String line;
                while ((line = br.readLine()) != null) {
                    if(!tran.containsKey(line)) {
                        bw.write(everythingElse);
                    } else {
                        bw.write(tran.get(line));
                    }
                    bw.newLine();
                    bw.flush();
                }
                br.close();
                bw.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public int getFileCount() {
        return this.fileCount;
    }

    public void printOpcodeHashMap() {
        System.out.println(sort(opcodeCount));
    }

    private int countFiles() {
        return dirListing.length;
    }

    //gets the top n most frequent opcodes from the family and assigns a symbol
    private LinkedHashMap<String,Character> getSymbolMapping(int n) {
        //getting the hashmap and sorting it
        HashMap<String, Integer> sorted = sort(opcodeCount);
        String[] topOpcodes = new String[n];

        int count = 0;
        Iterator<Map.Entry<String, Integer>> itr = sorted.entrySet().iterator();
        //iterates over the top n opcodes
        while(itr.hasNext() && count<n) {
            Map.Entry<String, Integer> entry = itr.next();
            topOpcodes[count] = entry.getKey();
            count++;
        }

        LinkedHashMap<String,Character> tran = new LinkedHashMap<>(); //contains the mapping of opcode to symbol
        for(int i=0; i<n; i++) {
            tran.put(topOpcodes[i],char2convert[i]);
        }
        return tran;
    }

    private void makeDir(String name) {
        File theDir = new File(name);
        if (!theDir.exists()){
            theDir.mkdirs();
        }
    }

    private void countOpcodes() {
        System.out.println("Getting opcode count for " + family.getName() +"...");
        //iterate through the files
        for(File file : dirListing) {
            try {
                Scanner in = new Scanner(file);
                String line;
                while(in.hasNextLine()) {
                    line = in.nextLine();
                    //check if the key is already in the map
                    if(opcodeCount.containsKey(line)) {
                        opcodeCount.put(line, opcodeCount.get(line) + 1);
                    } else {
                        //adds it to the hashmap
                        opcodeCount.put(line,1);
                    }
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
    }

    //sorts the hashmap (biggest to smallest)
    private LinkedHashMap<String,Integer> sort(LinkedHashMap<String, Integer> hm) {
        //Create a list from elements of HashMap
        List<Map.Entry<String, Integer> > list =
                new LinkedList<>(hm.entrySet());
        //Sort the list
        list.sort((o2, o1) -> (o1.getValue()).compareTo(o2.getValue()));

        //put data from sorted list to hashmap
        LinkedHashMap<String, Integer> temp = new LinkedHashMap<>();
        for (Map.Entry<String, Integer> aa : list) {
            temp.put(aa.getKey(), aa.getValue());
        }
        return temp;
    }

    //TODO make sure it folder "counts" does not exist create it, so it does not throw an exception
    //saves the opcode count to txt file
    public void save() {
        BufferedWriter bw = null;
        try {
            String path = System.getProperty("user.dir") + "/counts";
            File outFile = new File(path + "/" + family.getName() + "_opcodeCounts.txt");
            bw = new BufferedWriter(new FileWriter(outFile));

            for (Map.Entry<String, Integer> entry : opcodeCount.entrySet()) {
                bw.write(entry.getKey() + " " + entry.getValue());
                bw.newLine();
            }
            bw.flush();
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try {
                bw.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //maps character to an int, a = 0, b = 1, c = 2, etc, space = 26
    private static int map(char c) {
        if (c != ' ') {
            return (c - 'a');
        } else {
            return 26;
        }
    }

    private ArrayList<Integer> translateBrownToInt() {
        ArrayList<Integer> brown = new ArrayList<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader("./brown.txt"));
            String line = null;
            String s = "";
            while((line = br.readLine()) != null) {
                s += line;
            }
            //only goes for the first 50,000 characters
            for(int i=0; i<50000; i++) {
                brown.add(map(s.charAt(i)));
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
        return brown;
    }

    public static void main(String[] args) {
        String[] families = {"winwebsec", "zbot", "zeroAccess"};

        for(String family : families) {
            String path = System.getProperty("user.dir") + "/Malicia/" + family;
            Preprocessing pre = new Preprocessing(path);
            pre.save();
            System.out.println("File count: " + pre.getFileCount());
            //pre.translate(20);
        }
    }
}