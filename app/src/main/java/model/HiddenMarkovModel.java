package model;

import preprocessing.DataPrep;
import preprocessing.ObservationSequence;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class HiddenMarkovModel {
    private double[][] alpha;
    private double[][] beta;
    private double[][] gamma;
    private double[][][] diGamma;
    private double[] scaleFactors;
    private ObservationSequence observationSequence;
    private int N;
    private int M;
    private int T;
    private Lambda lambda;
    private int maxIterations;
    private ArrayList<ArrayList<Integer>> testSequences;
    private ArrayList<Double> sameFamilyScores = new ArrayList<>();
    private ArrayList<Double> otherFamilyScores = new ArrayList<>();


    public HiddenMarkovModel(int N, int M) {
        this.lambda = new Lambda(N, M);
        this.N = N;
        this.M = M;
    }

    private void init(String pathToFamily) {
        this.observationSequence = new ObservationSequence(pathToFamily,M-1);
        this.T = observationSequence.getT();
        this.scaleFactors = new double[T];
        alpha = new double[T][N];
        beta = new double[T][N];
        gamma = new double[T][N];
        diGamma = new double[T][N][N];
        this.testSequences = this.observationSequence.getPreprocessor().getTestSequences();
    }

    public void train(int maxIterations,String pathToFamily) {
        init(pathToFamily);
        int currentIteration = 0;
        double oldLogProb = Double.NEGATIVE_INFINITY;
        double logProb = -Double.MAX_VALUE;

        System.out.println("Started training HMM on " + observationSequence.getPreprocessor().getFamilyName() +"...");
        while ((currentIteration < maxIterations) && (logProb > oldLogProb)) {
            System.out.print("\titeration: "+currentIteration);
            oldLogProb = logProb;
            alphaPass();
            betaPass();
            gammaDiGammaPass();
            reEstimateLambda();

            currentIteration++;
            logProb = this.computeScore();
            System.out.print("\t- log probability: "+logProb+"\n");
        }
        this.maxIterations = currentIteration;
        System.out.println("Training completed!\n\tIterations: " + currentIteration + "\n\tFinal Training Score: " + logProb);
    }

    public void testFiles(String pathToOtherFamily) {
        try {
            System.out.println("Started testing...");
            testFilesSameFamily();
            testFilesOtherFamily(pathToOtherFamily);
            saveScores();
            System.out.println("Finished testing!");
        } catch(Exception e) {
            System.out.println("Error in testing/saving.");
        }
    }

    private ArrayList<Double> testFilesSameFamily() {
        double score;
        for(ArrayList<Integer> list : testSequences) {
            this.observationSequence.setObservationSequence(list);
            this.T = observationSequence.getObservationSequence().size();
            alphaPass();
            score = computeScore();
            this.sameFamilyScores.add(score);
        }
        return this.sameFamilyScores;
    }

    private ArrayList<Double> testFilesOtherFamily(String pathToOtherFamily) {
        ArrayList<ArrayList<Integer>> testSequences = this.observationSequence.getPreprocessor().createOtherTestSet(pathToOtherFamily,100);
        double score;
        for(ArrayList<Integer> list : testSequences) {
            this.observationSequence.setObservationSequence(list);
            this.T = observationSequence.getObservationSequence().size();
            alphaPass();
            score = computeScore();
            this.otherFamilyScores.add(score);
        }
        return this.otherFamilyScores;
    }

    public double computeScore() {
        double logProb = 0;
        for (int i = 0; i < T; i++) {
            logProb += Math.log(scaleFactors[i]);
        }
        logProb = -logProb;

        return logProb;
    }

    private void alphaPass() {
        scaleFactors[0] = 0;

        //computing alpha_0[i]
        for (int i = 0; i < N; i++) {
            alpha[0][i] = lambda.getPi()[i] * lambda.getB()[i][observationSequence.getObservationSequence().get(0)];
            scaleFactors[0] += alpha[0][i];
        }

        //scale alpha_0[i]
        scaleFactors[0] = 1 / scaleFactors[0];
        for (int i = 0; i < N; i++) {
            alpha[0][i] *= scaleFactors[0];
        }

        //compute alpha_t[i]
        for (int t = 1; t < T; t++) {
            scaleFactors[t] = 0;
            for (int i = 0; i < N; i++) {
                alpha[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    alpha[t][i] += alpha[t - 1][j] * lambda.getA()[j][i];
                }
                alpha[t][i] *= lambda.getB()[i][observationSequence.getObservationSequence().get(t)];
                scaleFactors[t] += alpha[t][i];
            }
            //scale alpha_t[i]
            scaleFactors[t] = 1 / scaleFactors[t];
            for (int i = 0; i < N; i++) {
                alpha[t][i] *= scaleFactors[t];
            }
        }
    }

    private void betaPass() {
        for (int i = 0; i < N; i++) {
            beta[T - 1][i] = scaleFactors[T - 1];
        }

        for (int t = T - 2; t >= 0; t--) {
            for (int i = 0; i < N; i++) {
                beta[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    beta[t][i] += lambda.getA()[i][j] * lambda.getB()[j][observationSequence.getObservationSequence().get(t + 1)] * beta[t + 1][j];
                }
                //scale beta_t[i]
                beta[t][i] *= scaleFactors[t];
            }
        }
    }

    private void gammaDiGammaPass() {
        for (int t = 0; t < T - 1; t++) {
            for (int i = 0; i < N; i++) {
                gamma[t][i] = 0;
                for (int j = 0; j < N; j++) {
                    diGamma[t][i][j] = alpha[t][i] * lambda.getA()[i][j] * lambda.getB()[j][observationSequence.getObservationSequence().get(t + 1)] * beta[t + 1][j];
                    gamma[t][i] += diGamma[t][i][j];
                }
            }
        }
        for (int i = 0; i < N; i++) {
            gamma[T - 1][i] = alpha[T - 1][i];
        }
    }

    private void reEstimateLambda() {
        //re-estimate pi
        for (int i = 0; i < N; i++) {
            lambda.setPi(gamma[0][i], i);
        }

        //re-estimate A
        for (int i = 0; i < N; i++) {
            double denom = 0;
            for (int t = 0; t < T - 1; t++) {
                denom += gamma[t][i];
            }
            for (int j = 0; j < N; j++) {
                double numer = 0;
                for (int t = 0; t < T - 1; t++) {
                    numer += diGamma[t][i][j];
                }
                double value = numer / denom;
                lambda.setA(value, i, j);
            }
        }

        //re-estimate B
        for (int i = 0; i < N; i++) {
            double denom = 0;
            for (int t = 0; t < T; t++) {
                denom += gamma[t][i];
            }
            for (int j = 0; j < M; j++) {
                double numer = 0;
                for (int t = 0; t < T; t++) {
                    if (observationSequence.getObservationSequence().get(t) == j)
                        numer += gamma[t][i];
                }
                double value = numer / denom;
                lambda.setB(value, i, j);
            }
        }
    }

    private void saveScores() {
        try {
            String familyName = observationSequence.getPreprocessor().getFamilyName();
            String otherFamilyName = observationSequence.getPreprocessor().getOtherFamilyName();
            String testName = familyName + "VS" + otherFamilyName;
            String dir = "../output/testingResults/" + observationSequence.getPreprocessor().getFamilyName()
                    + "/" + testName;
            DataPrep.makeDir(dir);
            String fileName = testName + "-" + N + "-" + M + "-" + maxIterations;
            File savedScores = new File(dir +"/" + fileName + ".csv");
            savedScores.createNewFile();

            BufferedWriter bw = new BufferedWriter(new FileWriter(savedScores));

            bw.write("score,class");
            bw.newLine();

            //0 == from same family
            //1 == from different family
            for(Double score : this.sameFamilyScores) {
                bw.write(Double.toString(score) + ","+ 0);
                bw.newLine();
            }
            for(Double score : this.otherFamilyScores) {
                bw.write(Double.toString(score) + ","+ 1);
                bw.newLine();
            }
            bw.flush();
            bw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void saveModel() {
        DataPrep.makeDir("../output/savedModels/"+observationSequence.getPreprocessor().getFamilyName());
        File savedModel = new File("../output/savedModels/"+observationSequence.getPreprocessor().getFamilyName()+"/" + observationSequence.getPreprocessor().getFamilyName()
                + "-" + N + "-" + M + "-" + maxIterations); //creates the file to save "familyname-N-M-maxIterations"
        try {
            savedModel.createNewFile();
            FileWriter writer = new FileWriter(savedModel);
            writer.write(Integer.toString(N) + "\n");
            writer.write(Integer.toString(M) + "\n");

            for (int i = 0; i < N; i++) {
                writer.write(Double.toString(lambda.getPi()[i]) + "\n");
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    writer.write(Double.toString(lambda.getA()[i][j]) + "\n");
                }
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    writer.write(Double.toString(lambda.getB()[i][j]) + "\n");
                }
            }

            writer.flush();
            writer.close();
        } catch(IOException e) {
            System.err.println("Error in writing model");
            System.exit(1);
        }
    }

    public void loadModel(String fileName) {
        File file = new File(fileName);
        try {
            Scanner sc = new Scanner(file);
            this.N = sc.nextInt();
            this.M = sc.nextInt();

            for(int i=0; i<N; i++) {
                double readValue = sc.nextDouble();
                lambda.setPi(readValue,i);
            }
            for(int i=0; i<N; i++) {
                for(int j=0; j<N; j++) {
                    double readValue = sc.nextDouble();
                    lambda.setA(readValue,i,j);
                }
            }

            for(int i=0; i<N; i++) {
                for(int j=0; j<M; j++) {
                    double readValue = sc.nextDouble();
                    lambda.setB(readValue,i,j);
                }
            }
            sc.close();
        } catch(IOException e) {
            System.err.println("Error in loading the model");
            System.exit(1);
        }
    }
}
