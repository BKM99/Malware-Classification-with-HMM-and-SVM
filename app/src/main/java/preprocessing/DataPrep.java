package preprocessing;

import java.io.*;
import java.util.*;

//takes in a family and processes it
public class DataPrep {
    private final static int SEED = 123;
    private Random rand = new Random(SEED);
    private File family;
    private File[] samples;
    private int numSamples;
    private int topKopcodes;
    private LinkedHashMap<String,Integer> opcodeCount;
    private ArrayList<Integer> observationSequence = new ArrayList<>();
    private ArrayList<ArrayList<Integer>> testSequences = new ArrayList<>();
    private LinkedHashMap<String,Integer> symbolMap;
    private HashSet<File> trainSet;
    private HashSet<File> testSet;
    private int observationSequenceSize = 70000;
    private File otherFamily;

    public DataPrep(File file, int topKopcodes) {
        this.family = file;
        this.samples = family.listFiles();
        this.numSamples = samples.length;
        this.topKopcodes = topKopcodes;
        System.out.println("Number of samples " + "in "+ getFamilyName() + ": " + this.numSamples);
        System.out.println("Started preprocessing "+family.getName()+"...");
        countOpcodes();
        saveOpcodeCount();
        getSymbolMapping();
        trainTestSplit();
        this.testSequences = createTestSet();
        System.out.println("Finished preprocessing "+family.getName()+"!");
    }

    public ArrayList<Integer> getObservationSequence() {
        return this.observationSequence;
    }

    public ArrayList<ArrayList<Integer>> getTestSequences() {
        return this.testSequences;
    }

    public String getFamilyName() {
        return this.family.getName();
    }

    public String getOtherFamilyName() {
        return this.otherFamily.getName();
    }

    //takes training set and converts it into the observation sequence
    private void translate() {
        BufferedReader br;
        try {
            String line;
            for(File sample : trainSet) {
                br = new BufferedReader(new FileReader(family + "/" + sample.getName()));
                while((line = br.readLine()) != null) {
                    if(observationSequence.size() >= observationSequenceSize)
                        break;
                    if(!symbolMap.containsKey(line))
                        this.observationSequence.add(symbolMap.get("everythingElse"));
                    else
                        this.observationSequence.add(symbolMap.get(line));
                }
                br.close();
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    //gets the top n most frequent opcodes from the family and assigns a symbol
    private void getSymbolMapping() {
        String[] topOpcodes = new String[topKopcodes];
        int count = 0;
        Iterator<Map.Entry<String, Integer>> itr = this.opcodeCount.entrySet().iterator();

        //iterates over the top n opcodes
        while (itr.hasNext() && count < topKopcodes) {
            Map.Entry<String, Integer> entry = itr.next();
            topOpcodes[count] = entry.getKey();
            count++;
        }

        LinkedHashMap<String, Integer> symbolMap = new LinkedHashMap<>(); //contains the mapping of opcode to symbol
        for (int i = 0; i < topKopcodes; i++) {
            symbolMap.put(topOpcodes[i], i);
        }
        symbolMap.put("everythingElse",topKopcodes);

        this.symbolMap = symbolMap;
    }

    //counts the opcodes then returns the hashmap sorted
    private void countOpcodes() {
        HashMap<String,Integer> opcodeCount = new HashMap<>(); //holds the opcode count

        for (File file : samples) {
            try {
                Scanner in = new Scanner(file);
                String line;
                while (in.hasNextLine()) {
                    line = in.nextLine();
                    //check if the key is already in the map
                    if (opcodeCount.containsKey(line)) {
                        opcodeCount.put(line, opcodeCount.get(line) + 1);
                    } else {
                        //new addition into the map
                        opcodeCount.put(line, 1);
                    }
                    // in.close();
                }
            } catch (FileNotFoundException e) {
                System.out.println("Error in counting opcodes for " + family.getName());
            }
        }
        this.opcodeCount = sort(opcodeCount);
    }

    //sorts the hashmap (biggest to smallest)
    private LinkedHashMap<String, Integer> sort(HashMap<String, Integer> opcodeCount) {
        List<Map.Entry<String, Integer>> list = new LinkedList<>(opcodeCount.entrySet());
        list.sort((o2, o1) -> (o1.getValue()).compareTo(o2.getValue()));

        //put data from sorted list to hashmap
        LinkedHashMap<String, Integer> sorted = new LinkedHashMap<>();
        for (Map.Entry<String, Integer> aa : list) {
            sorted.put(aa.getKey(), aa.getValue());
        }
        return sorted;
    }

    private void trainTestSplit() {
        trainSet = new HashSet<>();
        testSet = new HashSet<>();
        File randFile;

        //make training set
        while (trainSet.size() != 1200) {
            randFile = samples[rand.nextInt(this.numSamples)];
            this.trainSet.add(randFile);
        }

        //make testing set
        while (testSet.size() != 100) {
            randFile = samples[rand.nextInt(this.numSamples)];
            this.testSet.add(randFile);
        }
        translate();
    }

    //creates test set for the same family
    public ArrayList<ArrayList<Integer>> createTestSet() {
        ArrayList<ArrayList<Integer>> otherTestSet = new ArrayList<>(); //list of lists to hold multiple observation sequences
        ArrayList<Integer> testObservationSequence;
        String line;
        BufferedReader br;
        for(File testSample : testSet) {
            testObservationSequence = new ArrayList<>();
            try {
                br = new BufferedReader(new FileReader(testSample));
                while((line = br.readLine()) != null) {
                    if(!symbolMap.containsKey(line))
                        testObservationSequence.add(symbolMap.get("everythingElse"));
                    else
                        testObservationSequence.add(symbolMap.get(line));
                }
                br.close();

            } catch(Exception e) {
                e.printStackTrace();
            }
            otherTestSet.add(testObservationSequence);
        }

        return otherTestSet;
    }

    //creates other test set from different family
    public ArrayList<ArrayList<Integer>> createOtherTestSet(String pathToOtherFamily, int numOfSamples) {
        ArrayList<ArrayList<Integer>> otherTestSetSequences = new ArrayList<>(); //holds multiple observation sequences
        HashSet<File> otherTestSet = new HashSet<>(); //holds the files to be translated
        otherFamily = new File(pathToOtherFamily);
        File[] samples = otherFamily.listFiles();
        File randFile;

        //make testing set
        while (otherTestSet.size() != numOfSamples) {
            randFile = samples[rand.nextInt(numOfSamples)];
            otherTestSet.add(randFile);
        }

        ArrayList<Integer> otherTestObservationSequence;
        String line;
        BufferedReader br;
        for(File testSample : otherTestSet) {
            otherTestObservationSequence = new ArrayList<>();
            try {
                br = new BufferedReader(new FileReader(testSample));
                while((line = br.readLine()) != null) {
                    if(!symbolMap.containsKey(line))
                        otherTestObservationSequence.add(symbolMap.get("everythingElse"));
                    else
                        otherTestObservationSequence.add(symbolMap.get(line));
                }
                br.close();

            } catch(Exception e) {
                e.printStackTrace();
            }
            otherTestSetSequences.add(otherTestObservationSequence);
        }
        return otherTestSetSequences;
    }

    //saves the opcode count to txt file
    private void saveOpcodeCount() {
        //making the output folder if it does not exist, else do nothing
        makeDir("../output");
        makeDir("../output/opcodeCounts");

        BufferedWriter bw = null;
        try {
            String path = "../output/opcodeCounts";
            makeDir(path);
            File outFile = new File(path + "/" + family.getName() + "_opcodeCounts.txt");
            bw = new BufferedWriter(new FileWriter(outFile));

            for (Map.Entry<String, Integer> entry : opcodeCount.entrySet()) {
                bw.write(entry.getKey() + " " + entry.getValue());
                bw.newLine();
            }
            bw.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                bw.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //makes a directory if it does not exist
    public static void makeDir(String name) {
        File theDir = new File(name);
        if (!theDir.exists()) {
            theDir.mkdirs();
        }
    }
}
