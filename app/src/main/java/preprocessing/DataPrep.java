// package preprocessing;
//
// import java.io.*;
// import java.util.*;
//
// //takes in a family and processes it
// public class DataPrep {
//     private final static int SEED = 123;
//     private Random rand = new Random(SEED);
//     private File family;
//     private File[] samples;
//     private int numSamples;
//     private int topKopcodes;
//     private LinkedHashMap<String,Integer> opcodeCount;
//     private ArrayList<Integer> observationSequence = new ArrayList<>();
//     private ArrayList<ArrayList<Integer>> testSequences = new ArrayList<>();
//     private LinkedHashMap<String,Integer> symbolMap;
//     private HashSet<File> trainSet;
//     private HashSet<File> testSet;
//     private int observationSequenceSize = 70000;
//     private File otherFamily;
//
//     public DataPrep(File file, int topKopcodes) {
//         this.family = file;
//         this.samples = family.listFiles();
//         this.numSamples = samples.length;
//         this.topKopcodes = topKopcodes;
//         System.out.println("Number of samples " + "in "+ getFamilyName() + ": " + this.numSamples);
//         System.out.println("Started preprocessing "+family.getName()+"...");
//         countOpcodes();
//         saveOpcodeCount();
//         getSymbolMapping();
//         trainTestSplit();
//         this.testSequences = createTestSet();
//         System.out.println("Finished preprocessing "+family.getName()+"!");
//     }
//
//     public ArrayList<Integer> getObservationSequence() {
//         return this.observationSequence;
//     }
//
//     public ArrayList<ArrayList<Integer>> getTestSequences() {
//         return this.testSequences;
//     }
//
//     public String getFamilyName() {
//         return this.family.getName();
//     }
//
//     public String getOtherFamilyName() {
//         return this.otherFamily.getName();
//     }
//
//     //takes training set and converts it into the observation sequence
//     private void translate() {
//         BufferedReader br;
//         try {
//             String line;
//             for(File sample : trainSet) {
//                 br = new BufferedReader(new FileReader(family + "/" + sample.getName()));
//                 while((line = br.readLine()) != null) {
//                     if(observationSequence.size() >= observationSequenceSize)
//                         break;
//                     if(!symbolMap.containsKey(line))
//                         this.observationSequence.add(symbolMap.get("everythingElse"));
//                     else
//                         this.observationSequence.add(symbolMap.get(line));
//                 }
//                 br.close();
//             }
//         } catch(Exception e) {
//             e.printStackTrace();
//         }
//     }
//
//     //gets the top n most frequent opcodes from the family and assigns a symbol
//     private void getSymbolMapping() {
//         String[] topOpcodes = new String[topKopcodes];
//         int count = 0;
//         Iterator<Map.Entry<String, Integer>> itr = this.opcodeCount.entrySet().iterator();
//
//         //iterates over the top n opcodes
//         while (itr.hasNext() && count < topKopcodes) {
//             Map.Entry<String, Integer> entry = itr.next();
//             topOpcodes[count] = entry.getKey();
//             count++;
//         }
//
//         LinkedHashMap<String, Integer> symbolMap = new LinkedHashMap<>(); //contains the mapping of opcode to symbol
//         for (int i = 0; i < topKopcodes; i++) {
//             symbolMap.put(topOpcodes[i], i);
//         }
//         symbolMap.put("everythingElse",topKopcodes);
//
//         this.symbolMap = symbolMap;
//     }
//
//     //counts the opcodes then returns the hashmap sorted
//     private void countOpcodes() {
//         HashMap<String,Integer> opcodeCount = new HashMap<>(); //holds the opcode count
//
//         for (File file : samples) {
//             try {
//                 try (Scanner in = new Scanner(file)) {
//                     String line;
//                     while (in.hasNextLine()) {
//                         line = in.nextLine();
//                         //check if the key is already in the map
//                         if (opcodeCount.containsKey(line)) {
//                             opcodeCount.put(line, opcodeCount.get(line) + 1);
//                         } else {
//                             //new addition into the map
//                             opcodeCount.put(line, 1);
//                         }
//                     }
//                 }
//             } catch (FileNotFoundException e) {
//                 System.out.println("Error in counting opcodes for " + family.getName());
//             }
//         }
//         this.opcodeCount = sort(opcodeCount);
//     }
//
//     //sorts the hashmap (biggest to smallest)
//     private LinkedHashMap<String, Integer> sort(HashMap<String, Integer> opcodeCount) {
//         List<Map.Entry<String, Integer>> list = new LinkedList<>(opcodeCount.entrySet());
//         list.sort((o2, o1) -> (o1.getValue()).compareTo(o2.getValue()));
//
//         //put data from sorted list to hashmap
//         LinkedHashMap<String, Integer> sorted = new LinkedHashMap<>();
//         for (Map.Entry<String, Integer> aa : list) {
//             sorted.put(aa.getKey(), aa.getValue());
//         }
//         return sorted;
//     }
//
//     private void trainTestSplit() {
//         trainSet = new HashSet<>();
//         testSet = new HashSet<>();
//         File randFile;
//
//         //make training set
//         while (trainSet.size() != 1200) {
//             randFile = samples[rand.nextInt(this.numSamples)];
//             this.trainSet.add(randFile);
//         }
//
//         //make testing set
//         while (testSet.size() != 100) {
//             randFile = samples[rand.nextInt(this.numSamples)];
//             this.testSet.add(randFile);
//         }
//         translate();
//     }
//
//     //creates test set for the same family
//     public ArrayList<ArrayList<Integer>> createTestSet() {
//         ArrayList<ArrayList<Integer>> otherTestSet = new ArrayList<>(); //list of lists to hold multiple observation sequences
//         ArrayList<Integer> testObservationSequence;
//         String line;
//         BufferedReader br;
//         for(File testSample : testSet) {
//             testObservationSequence = new ArrayList<>();
//             try {
//                 br = new BufferedReader(new FileReader(testSample));
//                 while((line = br.readLine()) != null) {
//                     if(!symbolMap.containsKey(line))
//                         testObservationSequence.add(symbolMap.get("everythingElse"));
//                     else
//                         testObservationSequence.add(symbolMap.get(line));
//                 }
//                 br.close();
//
//             } catch(Exception e) {
//                 e.printStackTrace();
//             }
//             otherTestSet.add(testObservationSequence);
//         }
//
//         return otherTestSet;
//     }
//
//     //creates other test set from different family
//     public ArrayList<ArrayList<Integer>> createOtherTestSet(String pathToOtherFamily, int numOfSamples) {
//         ArrayList<ArrayList<Integer>> otherTestSetSequences = new ArrayList<>(); //holds multiple observation sequences
//         HashSet<File> otherTestSet = new HashSet<>(); //holds the files to be translated
//         otherFamily = new File(pathToOtherFamily);
//         File[] samples = otherFamily.listFiles();
//         File randFile;
//
//         //make testing set
//         while (otherTestSet.size() != numOfSamples) {
//             randFile = samples[rand.nextInt(numOfSamples)];
//             otherTestSet.add(randFile);
//         }
//
//         ArrayList<Integer> otherTestObservationSequence;
//         String line;
//         BufferedReader br;
//         for(File testSample : otherTestSet) {
//             otherTestObservationSequence = new ArrayList<>();
//             try {
//                 br = new BufferedReader(new FileReader(testSample));
//                 while((line = br.readLine()) != null) {
//                     if(!symbolMap.containsKey(line))
//                         otherTestObservationSequence.add(symbolMap.get("everythingElse"));
//                     else
//                         otherTestObservationSequence.add(symbolMap.get(line));
//                 }
//                 br.close();
//
//             } catch(Exception e) {
//                 e.printStackTrace();
//             }
//             otherTestSetSequences.add(otherTestObservationSequence);
//         }
//         return otherTestSetSequences;
//     }
//
//     //saves the opcode count to txt file
//     private void saveOpcodeCount() {
//         //making the output folder if it does not exist, else do nothing
//         makeDir("./output");
//         makeDir("./output/opcodeCounts");
//
//         BufferedWriter bw = null;
//         try {
//             String path = "./output/opcodeCounts";
//             makeDir(path);
//             File outFile = new File(path + "/" + family.getName() + "_opcodeCounts.txt");
//             bw = new BufferedWriter(new FileWriter(outFile));
//
//             for (Map.Entry<String, Integer> entry : opcodeCount.entrySet()) {
//                 bw.write(entry.getKey() + " " + entry.getValue());
//                 bw.newLine();
//             }
//             bw.flush();
//         } catch (Exception e) {
//             e.printStackTrace();
//         } finally {
//             try {
//                 bw.close();
//             } catch (Exception e) {
//                 e.printStackTrace();
//             }
//         }
//     }
//
//     //makes a directory if it does not exist
//     public static void makeDir(String name) {
//         File theDir = new File(name);
//         if (!theDir.exists()) {
//             theDir.mkdirs();
//         }
//     }
// }











package preprocessing;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class DataPrep {
    private static final int SEED = 123;
    private static final int TRAIN_SET_SIZE = 1200;
    private static final int TEST_SET_SIZE = 100;

    private Random rand = new Random(SEED);
    private File family;
    private File otherFamily;
    private File[] samples;
    private int numSamples;
    private int topKopcodes;
    private LinkedHashMap<String, Integer> opcodeCount;
    private ArrayList<Integer> observationSequence = new ArrayList<>();
    private ArrayList<ArrayList<Integer>> testSequences = new ArrayList<>();
    private LinkedHashMap<String, Integer> symbolMap;
    private HashSet<File> trainSet;
    private HashSet<File> testSet;
    private int observationSequenceSize = 70000;

    public DataPrep(File file, int topKopcodes) {
        this.family = file;
        this.samples = family.listFiles();
        this.numSamples = samples.length;
        this.topKopcodes = topKopcodes;
        System.out.println("Number of samples in " + getFamilyName() + ": " + this.numSamples);
        System.out.println("Started preprocessing " + family.getName() + "...");
        countOpcodes();
        saveOpcodeCount();
        getSymbolMapping();
        trainTestSplit();
        translate();
        this.testSequences = createTestSet();
        System.out.println("Finished preprocessing " + family.getName() + "!");
    }

    public ArrayList<Integer> getObservationSequence() {
        return this.observationSequence;
    }

    public ArrayList<ArrayList<Integer>> getTestSequences() {
        return this.testSequences;
    }

    public String getFamilyName() {
        return this.family.getName();
    }

    public String getOtherFamilyName() {
        return this.otherFamily.getName();
    }

    private void translate() {
        try {
            for (File sample : trainSet) {
                try (BufferedReader br = new BufferedReader(new FileReader(family + "/" + sample.getName()))) {
                    String line;
                    while ((line = br.readLine()) != null && observationSequence.size() < observationSequenceSize) {
                        int symbol = symbolMap.getOrDefault(line, symbolMap.get("everythingElse"));
                        observationSequence.add(symbol);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void getSymbolMapping() {
        String[] topOpcodes = opcodeCount.keySet().stream()
                .sorted((a, b) -> opcodeCount.get(b).compareTo(opcodeCount.get(a)))
                .limit(topKopcodes)
                .toArray(String[]::new);

        LinkedHashMap<String, Integer> symbolMap = new LinkedHashMap<>();
        for (int i = 0; i < topKopcodes; i++) {
            symbolMap.put(topOpcodes[i], i);
        }
        symbolMap.put("everythingElse", topKopcodes);

        this.symbolMap = symbolMap;
    }

    private void countOpcodes() {
        HashMap<String, Integer> opcodeCount = new HashMap<>();

        for (File file : samples) {
            try {
                try (Scanner in = new Scanner(file)) {
                    while (in.hasNextLine()) {
                        String line = in.nextLine();
                        opcodeCount.put(line, opcodeCount.getOrDefault(line, 0) + 1);
                    }
                }
            } catch (FileNotFoundException e) {
                System.out.println("Error in counting opcodes for " + family.getName());
            }
        }
        this.opcodeCount = sort(opcodeCount);
    }

    private LinkedHashMap<String, Integer> sort(HashMap<String, Integer> opcodeCount) {
        return opcodeCount.entrySet().stream()
                .sorted((a, b) -> b.getValue().compareTo(a.getValue()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
    }

    private void trainTestSplit() {
        trainSet = new HashSet<>();
        testSet = new HashSet<>();

        while (trainSet.size() != TRAIN_SET_SIZE) {
            File randFile = samples[rand.nextInt(numSamples)];
            trainSet.add(randFile);
        }

        while (testSet.size() != TEST_SET_SIZE) {
            File randFile = samples[rand.nextInt(numSamples)];
            testSet.add(randFile);
        }
    }

    public ArrayList<ArrayList<Integer>> createTestSet() {
        ArrayList<ArrayList<Integer>> otherTestSet = new ArrayList<>();
        for (File testSample : testSet) {
            ArrayList<Integer> testObservationSequence = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(testSample))) {
                String line;
                while ((line = br.readLine()) != null) {
                    int symbol = symbolMap.getOrDefault(line, symbolMap.get("everythingElse"));
                    testObservationSequence.add(symbol);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            otherTestSet.add(testObservationSequence);
        }
        return otherTestSet;
    }

    public ArrayList<ArrayList<Integer>> createOtherTestSet(String pathToOtherFamily, int numOfSamples) {
        ArrayList<ArrayList<Integer>> otherTestSetSequences = new ArrayList<>();
        HashSet<File> otherTestSet = new HashSet<>();
        otherFamily = new File(pathToOtherFamily);
        File[] otherSamples = otherFamily.listFiles();

        while (otherTestSet.size() != numOfSamples) {
            File randFile = otherSamples[rand.nextInt(numOfSamples)];
            otherTestSet.add(randFile);
        }

        for (File testSample : otherTestSet) {
            ArrayList<Integer> otherTestObservationSequence = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(testSample))) {
                String line;
                while ((line = br.readLine()) != null) {
                    int symbol = symbolMap.getOrDefault(line, symbolMap.get("everythingElse"));
                    otherTestObservationSequence.add(symbol);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            otherTestSetSequences.add(otherTestObservationSequence);
        }
        return otherTestSetSequences;
    }

    private void saveOpcodeCount() {
        makeDir("./output");
        makeDir("./output/opcodeCounts");

        try (BufferedWriter bw = new BufferedWriter(new FileWriter("./output/opcodeCounts/" + family.getName() + "_opcodeCounts.txt"))) {
            for (Map.Entry<String, Integer> entry : opcodeCount.entrySet()) {
                bw.write(entry.getKey() + " " + entry.getValue());
                bw.newLine();
            }
            bw.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void makeDir(String name) {
        File theDir = new File(name);
        if (!theDir.exists() && !theDir.mkdirs()) {
            System.out.println("Error creating directory: " + name);
        }
    }
}
